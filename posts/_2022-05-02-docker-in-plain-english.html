<!DOCTYPE html><html><head><script async="" defer="" data-domain="garrit.xyz" src="https://analytics.slashdev.space/js/plausible.outbound-links.js"></script><script>window.plausible = window.plausible || function() { (window.plausible.q = window.plausible.q || []).push(arguments) }</script><meta name="viewport" content="width=device-width, initial-scale=1"/><meta charSet="utf-8"/><title>Docker in plain english</title><meta name="Description" content="Generalist developer writing about fullstack development, system administration and free software."/><link rel="icon" type="image/svg+xml" href="/favicon.svg"/><link rel="webmention" href="https://webmention.io/garrit.xyz/webmention"/><link rel="pingback" href="https://webmention.io/garrit.xyz/xmlrpc"/><meta name="next-head-count" content="9"/><link rel="preload" href="https://garrit.xyz/_next/static/css/8e7046d3ef6ac6d8.css" as="style"/><link rel="stylesheet" href="https://garrit.xyz/_next/static/css/8e7046d3ef6ac6d8.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="https://garrit.xyz/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="https://garrit.xyz/_next/static/chunks/webpack-419417af898ef431.js" defer=""></script><script src="https://garrit.xyz/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="https://garrit.xyz/_next/static/chunks/main-01df828e572375b9.js" defer=""></script><script src="https://garrit.xyz/_next/static/chunks/pages/_app-6297bfd2dcc78ba7.js" defer=""></script><script src="https://garrit.xyz/_next/static/chunks/988-48b55eebb161e8d8.js" defer=""></script><script src="https://garrit.xyz/_next/static/chunks/746-6cb8fd2335c400fd.js" defer=""></script><script src="https://garrit.xyz/_next/static/chunks/768-d1db3457a00e9fa7.js" defer=""></script><script src="https://garrit.xyz/_next/static/chunks/pages/posts/%5Bpost%5D-204e11083399f3a3.js" defer=""></script><script src="https://garrit.xyz/_next/static/EdaXW_-dr5sdKk8Jtje4F/_buildManifest.js" defer=""></script><script src="https://garrit.xyz/_next/static/EdaXW_-dr5sdKk8Jtje4F/_ssgManifest.js" defer=""></script><script src="https://garrit.xyz/_next/static/EdaXW_-dr5sdKk8Jtje4F/_middlewareManifest.js" defer=""></script><style id="__jsx-8946a52cf42f2313">.layout.jsx-8946a52cf42f2313{overflow-x:hidden;
display:-webkit-box;
display:-webkit-flex;
display:-ms-flexbox;
display:flex;
-webkit-flex-direction:column;
-ms-flex-direction:column;
flex-direction:column;
min-height:100vh}
.layout.jsx-8946a52cf42f2313 .info_page.jsx-8946a52cf42f2313{color:#ebebeb}
.content.jsx-8946a52cf42f2313{}
@media (min-width:768px) {}</style></head><body><div id="__next" data-reactroot=""><section class="jsx-8946a52cf42f2313 layout"><header class="header"><nav class="nav" role="navigation" aria-label="main navigation"><div class="header__container"><a href="/" class="header__container__logo underlined">Garrit&#x27;s Notes</a></div><ul class="header__links"><li><a href="/posts" class="underlined">Blog</a></li><li><a href="/contact" class="underlined">Contact</a></li><li><a href="/cv" class="underlined">Resume</a></li></ul></nav></header><div class="jsx-8946a52cf42f2313 content"><article class="page h-entry"><div class="page__info"><h1 class="p-name">Docker in plain english</h1><h3 class="page__info__date">May 02 2022</h3></div><div class="page__body e-content"><p>Recently I saw some fellow Mastodon-users discussing resources and guides to get
into the docker ecosystem. Given that most of my private infrastructure is built
upon docker and docker-compose, I thought I&#x27;d share how <strong>I</strong> use this tool. I
will try to assume no prior container-knowledge, but if anything isn&#x27;t clear to
you, feel free to <a href="/contact">contact me</a>.</p>
<h2 id="docker-101" level="2">Docker 101</h2>
<p>First up: What on earth is Docker, and why should I use it?</p>
<p>Docker is a <em>container runtime</em>. It can be used to isolate system resources in a
reproducible manner, meaning if I containerize an application on my machine, I
can be sure that it will function exactly the same on all machines. The benefits
of this are obvious: You more or less eliminate all dependencies to a specific
environment, like the operating system and other software. As long as it&#x27;s the
same CPU-architecture, this sentence holds true: If it runs docker, it can run
your application.</p>
<p>Things running in a container also can&#x27;t break out of this &quot;sandbox&quot;. A process
in a container is only aware of the resources around it, not on the host
machine. Each container is kind of like an operating system <strong>inside</strong> your
actual operating system.</p>
<p>To describe what a container should look like, we need to write a &quot;recipe&quot; for
it. In it, you describe a starting point from which you want to build upon, and
the necessary steps to achieve the desired state. This &quot;recipe&quot; is called a
<code>Dockerfile</code>. A very simple Dockerfile might look like this:</p>
<pre><code>FROM ubuntu

RUN apt update &amp;&amp; apt upgrade -y

CMD [&quot;echo&quot;, &quot;Hello World!&quot;]
</code></pre>
<p>If you now run <code>docker build -t hello-world .</code>, docker will take this recipe and
build an <strong>image</strong> called &quot;hello-world&quot;. This image is a template that describes
the state of your application. In our case, we take the definition provided by
the &quot;ubuntu&quot; image and simply do a system update. Whenever you spawn a container
from this image, it will always start from exactly this state. Note that the
commands in the Dockerfile do not run every time you launch a container! An
image is the <strong>result</strong> of running the commands. The final instruction, <code>CMD</code>,
is the command to run whenever you spawn a container, but more on that later.</p>
<p>Congrats! You just built your very first docker image. To verify that it&#x27;s
actually there, try running <code>docker image ls</code>. This will list all images on your
system:</p>
<pre><code>➜  garrit.xyz git:(master) ✗ docker image ls 
REPOSITORY               TAG             IMAGE ID       CREATED          SIZE
hello-world              latest          6e2240011a89   8 minutes ago    109MB
</code></pre>
<p>An image doesn&#x27;t really do anything on its own. You need to tell docker to
construct a container out of that image. A container is essentially an
<strong>instance</strong> of that image. Try running this command:</p>
<pre><code>docker run hello-world
</code></pre>
<p>And, as instructed with the <code>CMD</code> line, you should see the words &quot;Hello World!&quot;
printed on the screen. You can verify that it&#x27;s still there by running <code>docker ps -a</code>, which will list all containers on your system, including the one you
just ran:</p>
<pre><code>CONTAINER ID   IMAGE                    COMMAND                  CREATED          STATUS                      PORTS                                            NAMES
05415bf66a91   hello-world              &quot;bash&quot;                   3 seconds ago    Exited (0) 2 seconds ago
</code></pre>
<p>&quot;This isn&#x27;t really helpful!&quot;, I hear you yell. You&#x27;re right, so let&#x27;s look at a
real world example.</p>
<h2 id="example:-a-simple-node.js-application" level="2">Example: A simple Node.js application</h2>
<p>A real world use case for a docker container is run your home-built application.
Say we have a basic Node.js app that we wanted to containerize:</p>
<pre><code>.
├── app.js
├── package-lock.json
└── package.json
</code></pre>
<p>And your main setup-workflow for this application looks something like this:</p>
<pre><code>npm install
npm start
</code></pre>
<p>Remember that a Dockerfile is a <strong>recipe</strong> of how an application is built. A
corresponding recipe could look like this:</p>
<pre><code class="language-Dockerfile"># Declare base image
FROM node:16

# Copy the application into the container
COPY . .

# Install dependencies
RUN npm install

# Launch the application
CMD [&quot;npm&quot;, &quot;start&quot;]
</code></pre>
<p>Like above, you can build this Dockerfile using <code>docker build -t testapp .</code>, or
any name you&#x27;d like to use.</p>
<blockquote>
<p><strong>Quick Tip</strong>: You might also want to add a <code>.Dockerignore</code> file, which lists
files and directories which should not be copied inside the container, just like
a <code>.gitignore</code> file. I usually add <code>node_modules</code> since it will be recreated
when building the image, and some files that are not relevant at runtime, like a
README.</p>
</blockquote>
<p>Running <code>docker image ls</code> should now show the image you just created:</p>
<pre><code>REPOSITORY               TAG             IMAGE ID       CREATED             SIZE
testapp                  latest          463e68d86eee   5 minutes ago       857MB
</code></pre>
<p>You can now &quot;run&quot; the image, which will result in a spawned container. Since
Containers run in their own environment, they won&#x27;t be able to receive any
keystrokes by default, so you can&#x27;t stop the application. To fix this, you can
use the <code>-it</code> flags, which will establish an interactive session to the process
inside the container. This makes it easier to stop the container after it is
created:</p>
<pre><code>docker run -it testapp
</code></pre>
<p>And voila! You should see the output of your application in the terminal. If
you&#x27;ve done some Node.js, this output might be familiar:</p>
<pre><code>➜  testapp git:(master) ✗ docker run -ti testapp

&gt; testapp@1.0.0 start
&gt; node app.js

Example app listening at http://:::8080
</code></pre>
<p>You&#x27;ll soon discover that you can&#x27;t access port 8080 on your machine. Docker has
a powerful networking engine, and each container has its own IP. You <em>could</em>
figure out the IP of your container and access it like that. A simpler approach
though is to just bind a port of your host machine to the container.  For
example, let&#x27;s bind our port 4000 to port 8081 of the container. This can be
done using the <code>-p</code> flag of the cli:</p>
<pre><code>docker run -p 4000:8081 -it testapp
</code></pre>
<blockquote>
<p><strong>Quick Tip</strong>: To remember the order of the container- and the host-port, I
always think of the container as laying on my desk. First, I grab the cable (the
host machine) and then plug it into the container. Weird analogy, I know. But it
really helped me make sense of this!</p>
</blockquote>
<p>If you now access <code>http://localhost:4000</code> on your host machine, you should see
your application!</p>
<h2 id="docker-compose-101" level="2">Docker Compose 101</h2>
<ul>
<li>Volumes</li>
<li>Networking</li>
<li>Env Variables</li>
</ul>
<h2 id="how-i-deploy-my-services" level="2">How I deploy my services</h2>
<ul>
<li>Walkthrough of a simple deployment (miniflux?)</li>
<li>Traefik</li>
<li>Local volumes</li>
<li>Permissions</li>
</ul>
<h2 id="conclusion" level="2">Conclusion</h2>
<ul>
<li>Image size optimizations</li>
</ul>
<p>This is post 030 of <a href="https://100daystooffload.com/">#100DaysToOffload</a>.</p><hr/><p><a href="mailto:garrit@slashdev.space?subject=Re: Docker%20in%20plain%20english">Reply via E-Mail</a></p><div class="page__tag-list"><svg class="page__tag-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><a href="/posts?tags=guide">#<!-- -->guide</a><a href="/posts?tags=docker">#<!-- -->docker</a><a href="/posts?tags=infrastructure">#<!-- -->infrastructure</a><a href="/posts?tags=100DaysToOffload">#<!-- -->100DaysToOffload</a></div></div></article></div><footer class="footer"><div class="footer__content"><section class="footer__content__links"><h3>Links of Interest</h3><a href="/rss.xml">RSS Feed</a><br/><a href="/todo">Todo List</a><br/><a href="https://keyoxide.org/hkp/garrit@slashdev.space">PGP Key</a><br/><a href="/blogroll">Blogroll</a></section><section class="footer__content__social"><h3>Elsewhere</h3><a href="https://github.com/garritfra" rel="me">Github</a><br/><a href="https://www.linkedin.com/in/garritfranke/">LinkedIn</a><br/><a href="https://fosstodon.org/@garritfra">Mastodon (ActivityPub)</a><br/><a href="/contact">Contact</a></section></div><p>© 2018-2022 Garrit Franke</p></footer></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"title":"Docker in plain english","date":"2022-05-02","tags":"guide, docker, infrastructure, 100DaysToOffload"},"markdownBody":"\nRecently I saw some fellow Mastodon-users discussing resources and guides to get\ninto the docker ecosystem. Given that most of my private infrastructure is built\nupon docker and docker-compose, I thought I'd share how **I** use this tool. I\nwill try to assume no prior container-knowledge, but if anything isn't clear to\nyou, feel free to [contact me](/contact).\n\n## Docker 101\n\nFirst up: What on earth is Docker, and why should I use it?\n\nDocker is a _container runtime_. It can be used to isolate system resources in a\nreproducible manner, meaning if I containerize an application on my machine, I\ncan be sure that it will function exactly the same on all machines. The benefits\nof this are obvious: You more or less eliminate all dependencies to a specific\nenvironment, like the operating system and other software. As long as it's the\nsame CPU-architecture, this sentence holds true: If it runs docker, it can run\nyour application.\n\nThings running in a container also can't break out of this \"sandbox\". A process\nin a container is only aware of the resources around it, not on the host\nmachine. Each container is kind of like an operating system **inside** your\nactual operating system. \n\nTo describe what a container should look like, we need to write a \"recipe\" for\nit. In it, you describe a starting point from which you want to build upon, and\nthe necessary steps to achieve the desired state. This \"recipe\" is called a\n`Dockerfile`. A very simple Dockerfile might look like this:\n\n```\nFROM ubuntu\n\nRUN apt update \u0026\u0026 apt upgrade -y\n\nCMD [\"echo\", \"Hello World!\"]\n```\n\nIf you now run `docker build -t hello-world .`, docker will take this recipe and\nbuild an **image** called \"hello-world\". This image is a template that describes\nthe state of your application. In our case, we take the definition provided by\nthe \"ubuntu\" image and simply do a system update. Whenever you spawn a container\nfrom this image, it will always start from exactly this state. Note that the\ncommands in the Dockerfile do not run every time you launch a container! An\nimage is the **result** of running the commands. The final instruction, `CMD`,\nis the command to run whenever you spawn a container, but more on that later.\n\nCongrats! You just built your very first docker image. To verify that it's\nactually there, try running `docker image ls`. This will list all images on your\nsystem:\n\n```\n➜  garrit.xyz git:(master) ✗ docker image ls \nREPOSITORY               TAG             IMAGE ID       CREATED          SIZE\nhello-world              latest          6e2240011a89   8 minutes ago    109MB\n```\n\nAn image doesn't really do anything on its own. You need to tell docker to\nconstruct a container out of that image. A container is essentially an\n**instance** of that image. Try running this command:\n\n```\ndocker run hello-world\n```\n\nAnd, as instructed with the `CMD` line, you should see the words \"Hello World!\"\nprinted on the screen. You can verify that it's still there by running `docker\nps -a`, which will list all containers on your system, including the one you\njust ran:\n\n```\nCONTAINER ID   IMAGE                    COMMAND                  CREATED          STATUS                      PORTS                                            NAMES\n05415bf66a91   hello-world              \"bash\"                   3 seconds ago    Exited (0) 2 seconds ago\n```\n\n\"This isn't really helpful!\", I hear you yell. You're right, so let's look at a\nreal world example.\n\n## Example: A simple Node.js application\n\nA real world use case for a docker container is run your home-built application.\nSay we have a basic Node.js app that we wanted to containerize:\n\n```\n.\n├── app.js\n├── package-lock.json\n└── package.json\n```\n\nAnd your main setup-workflow for this application looks something like this:\n\n```\nnpm install\nnpm start\n```\n\nRemember that a Dockerfile is a **recipe** of how an application is built. A\ncorresponding recipe could look like this:\n\n```Dockerfile\n# Declare base image\nFROM node:16\n\n# Copy the application into the container\nCOPY . .\n\n# Install dependencies\nRUN npm install\n\n# Launch the application\nCMD [\"npm\", \"start\"]\n```\n\nLike above, you can build this Dockerfile using `docker build -t testapp .`, or\nany name you'd like to use.\n\n\u003e **Quick Tip**: You might also want to add a `.Dockerignore` file, which lists\nfiles and directories which should not be copied inside the container, just like\na `.gitignore` file. I usually add `node_modules` since it will be recreated\nwhen building the image, and some files that are not relevant at runtime, like a\nREADME.\n\nRunning `docker image ls` should now show the image you just created:\n\n```\nREPOSITORY               TAG             IMAGE ID       CREATED             SIZE\ntestapp                  latest          463e68d86eee   5 minutes ago       857MB\n```\n\nYou can now \"run\" the image, which will result in a spawned container. Since\nContainers run in their own environment, they won't be able to receive any\nkeystrokes by default, so you can't stop the application. To fix this, you can\nuse the `-it` flags, which will establish an interactive session to the process\ninside the container. This makes it easier to stop the container after it is\ncreated:\n\n```\ndocker run -it testapp\n```\n\nAnd voila! You should see the output of your application in the terminal. If\nyou've done some Node.js, this output might be familiar:\n\n```\n➜  testapp git:(master) ✗ docker run -ti testapp\n\n\u003e testapp@1.0.0 start\n\u003e node app.js\n\nExample app listening at http://:::8080\n```\n\nYou'll soon discover that you can't access port 8080 on your machine. Docker has\na powerful networking engine, and each container has its own IP. You _could_\nfigure out the IP of your container and access it like that. A simpler approach\nthough is to just bind a port of your host machine to the container.  For\nexample, let's bind our port 4000 to port 8081 of the container. This can be\ndone using the `-p` flag of the cli:\n\n```\ndocker run -p 4000:8081 -it testapp\n```\n\n\u003e **Quick Tip**: To remember the order of the container- and the host-port, I\nalways think of the container as laying on my desk. First, I grab the cable (the\nhost machine) and then plug it into the container. Weird analogy, I know. But it\nreally helped me make sense of this!\n\nIf you now access `http://localhost:4000` on your host machine, you should see\nyour application!\n\n## Docker Compose 101\n\n* Volumes\n* Networking\n* Env Variables\n\n## How I deploy my services\n\n* Walkthrough of a simple deployment (miniflux?)\n* Traefik\n* Local volumes\n* Permissions\n\n## Conclusion\n\n* Image size optimizations\n\nThis is post 030 of [#100DaysToOffload](https://100daystooffload.com/)."},"__N_SSG":true},"page":"/posts/[post]","query":{"post":"_2022-05-02-docker-in-plain-english"},"buildId":"EdaXW_-dr5sdKk8Jtje4F","assetPrefix":"https://garrit.xyz","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>